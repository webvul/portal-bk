package com.kii.beehive.portal.manager;


import java.util.Collections;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import com.kii.beehive.portal.auth.AuthInfoStore;
import com.kii.beehive.portal.entitys.AuthRestBean;
import com.kii.beehive.portal.exception.UnauthorizedException;
import com.kii.beehive.portal.helper.AuthInfoCacheService;
import com.kii.beehive.portal.helper.AuthInfoPermanentTokenService;
import com.kii.beehive.portal.jdbc.dao.TeamDao;
import com.kii.beehive.portal.jdbc.dao.TeamUserRelationDao;
import com.kii.beehive.portal.jdbc.entity.Team;
import com.kii.beehive.portal.service.BeehiveUserDao;
import com.kii.beehive.portal.store.entity.AuthInfoEntry;
import com.kii.beehive.portal.store.entity.BeehiveUser;
import com.kii.extension.sdk.annotation.BindAppByName;
import com.kii.extension.sdk.context.UserTokenBindTool;
import com.kii.extension.sdk.entity.LoginInfo;
import com.kii.extension.sdk.service.UserService;

@BindAppByName(appName = "master")
@Component
@Transactional

public class AuthManager {

	private Logger log = LoggerFactory.getLogger(AuthManager.class);

	@Autowired
	private BeehiveUserDao userDao;

	@Autowired
	private AuthInfoCacheService authInfoCacheService;

	@Autowired
	private AuthInfoPermanentTokenService authInfoPermanentTokenService;

	@Autowired
	private UserTokenBindTool userTokenBindTool;

	@Autowired
	private UserService userService;



	@Autowired
	private TeamDao teamDao;

	@Autowired
	protected TeamUserRelationDao teamUserRelationDao;
	/**
	 * register with userID and password
	 * the logic behind is as below:
	 * 1. login with the default password (generated by KiiUserSyncDao when created beehive user)
	 * 2. change password with the token from login
	 *
	 * @param userID
	 * @param password
	 */
	public boolean activity(String userID, String token) {

		// TODO need to check why below was ever commented out?
//			String defaultPassword = this.getDefaultPassword(user);

		BeehiveUser user = userDao.getUserByID(userID);


		if(StringUtils.isEmpty(user.getActivityToken())){
//			throw new UnauthorizedException("the activity token invalid or outdate");
			return false;
		}
		boolean sign = user.getActivityToken().equals(user.getHashedPwd(token));

		if (sign) {
			//one-time token
			userDao.updateWithVerify(userID, Collections.singletonMap("activityToken", null), user.getVersion());
		}

		return sign;
	}

	public void initPassword(String userID,String newPassword) {


		BeehiveUser  user=userDao.getUserByID(userID);

		String pwd=user.getDefaultPassword();


		String newPwd=user.getHashedPwd(newPassword);

		userService.changePassword(pwd,newPwd);

	}



	/**
	 * login Kii Cloud and save the auth info
	 *
	 * @param userID
	 * @param password
	 * @param permanentToken true: save auth info into permanent token cache and DB;
	 *                       false: save auth info into auth info cache only
	 * @return
	 */
	public AuthRestBean login(String userID, String password, boolean permanentToken) {

		// login Kii Cloud
		LoginInfo loginInfo = null;

		BeehiveUser  user=userDao.getUserByID(userID);
		String pwd=user.getHashedPwd(password);

		loginInfo = userService.login(userID, pwd);
		AuthInfoEntry authInfoEntry = null;
		if (permanentToken) {
			authInfoEntry = authInfoPermanentTokenService.saveToken(userID, loginInfo.getToken());
		} else {
			authInfoEntry = authInfoCacheService.saveToken(userID, loginInfo.getToken());
		}

		if(loginInfo == null) {
			throw new UnauthorizedException( "Authentication failed");
		}

		// get user info
		BeehiveUser beehiveUser = userDao.getUserByID(userID);

		AuthRestBean authRestBean = new AuthRestBean();
		authRestBean.setUser(beehiveUser);

		Team team = teamDao.getTeamByUserID(userID);
		if(team != null){
			authRestBean.setTeamID(team.getId());
			authRestBean.setTeamName(team.getName());
		}

		// get access token
		String accessToken = loginInfo.getToken();
		authRestBean.setAccessToken(accessToken);
		return authRestBean;
	}

	/**
	 * change the Kii user password in Kii Cloud;
	 * if success, remove the token
	 *
	 * @param oldPassword
	 * @param newPassword
	 */
	public void changePassword(String oldPassword, String newPassword) {

		BeehiveUser  user=userDao.getUserByID(AuthInfoStore.getUserID());

		String pwd=user.getHashedPwd(oldPassword);
		String newPwd=user.getHashedPwd(newPassword);

		userService.changePassword(pwd, newPwd);

		// remove the auth info from auth info cache
		String token = userTokenBindTool.getToken();
		authInfoCacheService.removeToken(token);

		// remove the auth info from permanent token cache and DB
		String userID = AuthInfoStore.getUserID();
		this.removePermanentToken(userID);
	}

	/**
	 * remove token from permanent token cache and DB
	 *
	 * @param userID
	 */
	private void removePermanentToken(String userID) {

		// remove token from DB
		List<String> tokenList = authInfoPermanentTokenService.removeTokenFromDBByUserID(userID);

		// remove token from cache
		for (String token : tokenList) {
			authInfoPermanentTokenService.removeTokenFromCache(token);
		}

	}

	/**
	 * validate user token,
	 * if token is valid, set it into ThreadLocal
	 *
	 * @param token
	 * @return
	 */
	public AuthInfoEntry validateAndBindUserToken(String token) throws UnauthorizedException {

		// try to get auth info from auth info cache by token
		AuthInfoEntry authInfo = authInfoCacheService.getAuthInfo(token);

		// if auth info not found in auth info cache, try to get it from permanent token cache or DB
		if (authInfo == null) {
			authInfo = authInfoPermanentTokenService.getAuthInfo(token);
		}

		// if auth info not found in both cache and DB, throw Exception
		if (authInfo == null) {
			throw new UnauthorizedException("invaild token");
		}

		userTokenBindTool.bindToken(authInfo.getToken());

		return authInfo;
	}

	/**
	 * remove the token
	 *
	 * @param token
	 */
	public void logout(String token) {

		// remove token from auth info cache
		authInfoCacheService.removeToken(token);

		// remove token from permanent token cache and DB
		authInfoPermanentTokenService.removeToken(token);
	}

	/**
	 * clean the user token in ThreadLocal
	 */
	public void unbindUserToken() {
		userTokenBindTool.clean();
	}

	/**
	 * get auth info entry by token <br/>
	 * this method is supposed to be called after AuthInterceptor validated the token
	 *
	 * @param token
	 * @return null if the corresponding auth info entry doesn't exist
	 */
	private AuthInfoEntry getAuthInfoEntry(String token) {
		if (StringUtils.isEmpty(token)) {
			return null;
		}

		AuthInfoEntry authInfoEntry = authInfoCacheService.getAuthInfo(token);

		if (authInfoEntry == null) {
			authInfoEntry = authInfoPermanentTokenService.getAuthInfo(token);
		}

		return authInfoEntry;
	}


	private  Team getTeamByID(String userID) {
		List<Team> teamList = teamDao.findTeamByUserID(userID);
		if (teamList != null && teamList.size() > 0) {
			return teamList.get(0);
		} else {
			return null;
		}
	}

	public AuthRestBean validateUserToken(String token){

		AuthInfoEntry entry = getAuthInfoEntry(token);

		// this case would rarely happen, because token is validated in AuthInterceptor before coming here
		if(entry == null) {
			throw new UnauthorizedException("the token cannot been found");
		}

		String userID = entry.getUserID();


		AuthRestBean authRestBean = new AuthRestBean();

		// get access token
		String accessToken = entry.getToken();
		authRestBean.setAccessToken(accessToken);

		// get user info
		BeehiveUser beehiveUser = userDao.getUserByID(userID);

		authRestBean.setUser(beehiveUser);

		Team team = getTeamByID(userID);
		if(team != null){
			authRestBean.setTeamID(team.getId());
			authRestBean.setTeamName(team.getName());
		}


		return authRestBean;
	}

}

